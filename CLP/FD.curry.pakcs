------------------------------------------------------------------------------
--- Library for finite domain constraint solving.
------------------------------------------------------------------------------

module CLP.FD
  ( FDConstr, FDExpr, FDRel(..), Option(..), fdc
  , allDifferent, domain, sum, scalarProduct, count
  , (=#), (/=#), (<#), (<=#), (>#), (>=#)
  , true, (/\), andC, allC
  , solve
  ) where

import qualified CLPFD as C
import qualified Constraint

infixl 7 *#
infixl 6 +#, -#
infix  4 =#, /=#, <#, <=#, >#, >=#
infixr 3 /\

-- abstract type for FD expressions
data FDExpr = FDVar Int Int Int -- variable with domain and value
            | FDInt Int
            | FDBinExp FDOp FDExpr FDExpr
 deriving Show

data FDOp = Plus | Minus | Times
 deriving Show

-- abstract type for FD constraints
data FDConstr = FDTrue
  | FDRelCon  FDRel FDExpr FDExpr
  | FDAnd     FDConstr FDConstr
  | FDAllDiff [FDExpr]
  | FDSum     [FDExpr]          FDRel FDExpr
  | FDScalar  [FDExpr] [FDExpr] FDRel FDExpr
  | FDCount   FDExpr   [FDExpr] FDRel FDExpr
 deriving Show

data FDRel = Equ | Neq | LT | LEQ | GT | GEQ
 deriving Show

--- Returns infinite list of FDVars with a given domain.
--- @param min - minimum value for all variables in xs
--- @param max - maximum value for all variables in xs
domain :: Int -> Int -> [FDExpr]
domain min max = genFDVars min max

genFDVars :: Int -> Int -> [FDExpr]
genFDVars l u = FDVar l u _ : genFDVars l u

-- get value (possibly an unbound variable) of an FD expression:
getFDVal :: FDExpr -> Int
getFDVal var = case var of
  FDVar _ _ v -> v
  FDInt i     -> i
  FDBinExp fdop fde1 fde2 -> (arithOp fdop) (valOf fde1) (valOf fde2)
 where
  valOf e = case e of
    FDInt i -> i
    FDBinExp op e1 e2 -> (arithOp op) (valOf e1) (valOf e2)
    _ -> error $ "FD variable or value expected but FD expression found:\n"++
                 show e

  arithOp Plus = (+)
  arithOp Minus = (-)
  arithOp Times = (*)

instance Num FDExpr where
  x + y = x +# y
  x - y = x -# y
  x * y = x *# y

  abs _ = error "abs undefined"

  signum _ = error "signum undefined"

  fromInteger x = fdc x

-- Represent an integer values as an FD expression.
fdc :: Int -> FDExpr
fdc v = FDInt v

--- Addition of FD variables.
(+#) :: FDExpr -> FDExpr -> FDExpr
x +# y = FDBinExp Plus x y

--- Subtraction of FD variables.
(-#) :: FDExpr -> FDExpr -> FDExpr
x -# y = FDBinExp Minus x y

--- Multiplication of FD variables.
(*#) :: FDExpr -> FDExpr -> FDExpr
x *# y = FDBinExp Times x y

--- Equality of FD variables or expressions.
(=#) :: FDExpr -> FDExpr -> FDConstr
x =# y = FDRelCon Equ x y

--- Disequality of FD variables or expressions.
(/=#) :: FDExpr -> FDExpr -> FDConstr
x /=# y = FDRelCon Neq x y

--- "Less than" constraint on FD variables or expressions.
(<#) :: FDExpr -> FDExpr -> FDConstr
x <# y = FDRelCon LT x y

--- "Less than or equal" constraint on FD variables or expressions.
(<=#) :: FDExpr -> FDExpr -> FDConstr
x <=# y = FDRelCon LEQ x y

--- "Greater than" constraint on FD variables or expressions.
(>#) :: FDExpr -> FDExpr -> FDConstr
x ># y = FDRelCon GT x y

--- "Greater than or equal" constraint on FD variables or expressions.
(>=#) :: FDExpr -> FDExpr -> FDConstr
x >=# y = FDRelCon GEQ x y

--- The always satisfied FD constraint.
true :: FDConstr
true = FDTrue

--- Conjunction of FD constraints.
(/\) :: FDConstr -> FDConstr -> FDConstr
c1 /\ c2 = FDAnd c1 c2

--- Conjunction of a list of FD constraints.
andC :: [FDConstr] -> FDConstr
andC = foldr (/\) true

--- Maps a constraint abstraction to a list of FD constraints and joins them.
allC :: (a -> FDConstr) -> [a] -> FDConstr
allC c = andC . map c

---------------------------------------------------------------------------
-- Complex constraints.

--- "All different" constraint on FD variables.
--- @param xs - list of FD variables
--- @return satisfied if the FD variables in the argument list xs
---         have pairwise different values.
allDifferent :: [FDExpr] -> FDConstr
allDifferent vs = FDAllDiff vs

--- Relates the sum of FD variables with some integer of FD variable.
sum :: [FDExpr] -> FDRel -> FDExpr -> FDConstr
sum vs rel v = FDSum vs rel v

--- (scalarProduct cs vs relop v) is satisfied if (sum (cs*vs) relop v)
--- is satisfied.
--- The first argument must be a list of integers. The other arguments are as
--- in <code>sum</code>.
scalarProduct :: [FDExpr] -> [FDExpr] -> FDRel -> FDExpr -> FDConstr
scalarProduct cs vs rel v = FDScalar cs vs rel v

--- (count v vs relop c) is satisfied if (n relop c), where n is the number of
--- elements in the list of FD variables vs that are equal to v, is satisfied.
--- The first argument must be an integer. The other arguments are as
--- in <code>sum</code>.
count :: FDExpr -> [FDExpr] -> FDRel -> FDExpr -> FDConstr
count v vs rel c = FDCount v vs rel c

------------------------------------------------------------------------
-- The solver is implemented by a transformation into the old CLPFD solver:

--- This datatype contains all options to control the instantiated of FD variables
--- with the enumeration constraint <code>labeling</code>.
--- @cons LeftMost - The leftmost variable is selected for instantiation (default)
--- @cons FirstFail - The leftmost variable with the smallest domain is selected
---                   (also known as first-fail principle)
--- @cons FirstFailConstrained - The leftmost variable with the smallest domain
---                              and the most constraints on it is selected.
--- @cons Min - The leftmost variable with the smalled lower bound is selected.
--- @cons Max - The leftmost variable with the greatest upper bound is selected.
--- @cons Step - Make a binary choice between <code>x=#b</code> and
---              <code>x/=#b</code> for the selected variable
---              <code>x</code> where <code>b</code> is the lower or
---              upper bound of <code>x</code> (default).
--- @cons Enum - Make a multiple choice for the selected variable for all the values
---              in its domain.
--- @cons Bisect - Make a binary choice between <code>x&lt;=#m</code> and
---                <code>x&gt;#m</code> for the selected variable
---                <code>x</code> where <code>m</code> is the midpoint
---                of the domain <code>x</code>
---                (also known as domain splitting).
--- @cons Up - The domain is explored for instantiation in ascending order (default).
--- @cons Down - The domain is explored for instantiation in descending order.
--- @cons All - Enumerate all solutions by backtracking (default).
--- @cons Minimize v - Find a solution that minimizes the domain variable v
---                    (using a branch-and-bound algorithm).
--- @cons Maximize v - Find a solution that maximizes the domain variable v
---                    (using a branch-and-bound algorithm).
--- @cons Assumptions x - The variable x is unified with the number of choices
---                       made by the selected enumeration strategy when a solution
---                       is found.

data Option = LeftMost
            | FirstFail
            | FirstFailConstrained
            | Min
            | Max
            | Step
            | Enum
            | Bisect
            | Up
            | Down
            | All
            | Minimize Int
            | Maximize Int
            | Assumptions Int
  deriving Show

--- Computes (non-deterministically) a solution for the FD variables (third
--- argument) w.r.t. constraint (second argument).
solve :: [Option] -> [FDExpr] -> FDConstr -> [Int]
solve options cvars constr =
  let domconstr = Constraint.allC (\ (FDVar l u v) -> C.domain [v] l u)
                                  (allFDVars constr)
      tconstr = trC constr
      allvars = map getFDVal cvars
      labelvars = C.labeling (map trO options) allvars
   in (domconstr & tconstr & labelvars) &> allvars

-- compute (multi-set) of all variables occurring in a constraint:
allFDVars :: FDConstr -> [FDExpr]
allFDVars FDTrue = []
allFDVars (FDRelCon _ fde1 fde2)     = allEFDVars fde1 ++ allEFDVars fde2
allFDVars (FDAnd      c1 c2)         = allFDVars c1 ++ allFDVars c2
allFDVars (FDAllDiff fdvars)         = filterVars fdvars
allFDVars (FDSum fdvars _ fdv)       = filterVars (fdvars ++ [fdv])
allFDVars (FDScalar cs fdvars _ fdv) = filterVars (cs ++ fdvars ++ [fdv])
allFDVars (FDCount fdv fdvars _ c)   = filterVars (fdvars ++ [fdv,c])

-- filter variables in a list of FD expressions
filterVars :: [FDExpr] -> [FDExpr]
filterVars = concatMap allEFDVars

allEFDVars :: FDExpr -> [FDExpr]
allEFDVars e = case e of
  FDVar _ _ _      -> [e]
  FDInt _          -> []
  FDBinExp _ e1 e2 -> allEFDVars e1 ++ allEFDVars e2

trC :: FDConstr -> Success
trC FDTrue = success
trC (FDRelCon rel fde1 fde2) = (trFDRel rel) (trE fde1) (trE fde2)
trC (FDAnd fde1 fde2) = trC fde1 & trC fde2
trC (FDAllDiff fdvars) = C.allDifferent (map getFDVal fdvars)
trC (FDSum fdvars relop fdv) =
  C.sum (map getFDVal fdvars)
        (trFDRel relop) --(\e1 e2 -> trC (rel (FDInt e1) (FDInt e2)))
        (getFDVal fdv)
trC (FDScalar cs fdvars relop fdv) =
  C.scalarProduct (map getFDVal cs) (map getFDVal fdvars) (trFDRel relop)
                  (getFDVal fdv)
trC (FDCount fdv fdvars relop c) =
  C.count (getFDVal fdv) (map getFDVal fdvars) (trFDRel relop) (getFDVal c)

trE :: FDExpr -> Int
trE (FDVar _ _ v) = v
trE (FDInt i) = i
trE (FDBinExp rel fde1 fde2) = (trFDOp rel) (trE fde1) (trE fde2)

trFDRel Equ = (C.=#)
trFDRel Neq = (C./=#)
trFDRel LT  = (C.<#)
trFDRel LEQ = (C.<=#)
trFDRel GT  = (C.>#)
trFDRel GEQ = (C.>=#)

trFDOp Plus  = (C.+#)
trFDOp Minus = (C.-#)
trFDOp Times = (C.*#)

trO option = case option of
  LeftMost             -> C.LeftMost
  FirstFail            -> C.FirstFail
  FirstFailConstrained -> C.FirstFailConstrained
  _                    -> error $ "Unknown option: " ++ show option

------------------------------------------------------------------------
-- Examples

ex1 = let vs@[x,y,z] = take 3 (domain 0 1)
          cs = x /=# y /\ y /=# z
       in solve [] vs cs

smm :: [Int]
smm =
 let xs@[s,e,n,d,m,o,r,y] = take 8 (domain 0 9)

     constraints =
        s ># fdc 0 /\
        m ># fdc 0 /\
        allDifferent xs /\
           fdc 1000  *# s +# fdc 100  *# e +# fdc 10  *# n +# d
        +# fdc 1000  *# m +# fdc 100  *# o +# fdc 10  *# r +# e
        =# fdc 10000 *# m +# fdc 1000 *# o +# fdc 100 *# n +# fdc 10 *# e +# y
 in solve [] xs constraints

smm' =
 let xs@[s,e,n,d,m,o,r,y] = take 8 (domain 0 9)

     constraints =
        s ># 0 /\
        m ># 0 /\
        allDifferent xs /\
                       1000 * s + 100 * e + 10 * n + d
                     + 1000 * m + 100 * o + 10 * r + e
        =# 10000 * m + 1000 * o + 100 * n + 10 * e + y
 in solve [] xs constraints

------------------------------------------------------------------------