FiniteMap --> Data.Map

The data type changed from "FM" to "Map".
The explicit ordering function is not necessary anymore,
instead an "Ord" context is needed.
The type "Set" in now in Data.Set.
Renames from "Set":

FiniteSet  --> Set
emptySet   --> empty
mkSet      --> fromList
isEmptySet --> null
elementOf  --> member
minusSet   --> difference
setToList  --> toList
union      --> union

Renames from "Map":

FM                  --> Map
emptyFM             --> empty
unitFM              --> singleton
listToFM            --> fromList
addToFM             --> insert                | argument order changed!
addToFM_C           --> insertWith            | argument order changed!
addListToFM         --> insertList            | argument order changed!
addListToFM_C       --> insertListWith        | argument order changed!
delFromFM           --> delete                | argument order changed!
delListFromFM       --> deleteAll             | argument order changed!
updFM               --> adjust                | argument order changed!
splitFM             --> splitLookup           | return type changed!
plusFM              --> union                 | first two arguments are swapped!
plusFM_C            --> unionWith
minusFM             --> difference
intersectFM         --> intersection
intersectFM_C       --> intersectionWith
foldFM              --> foldrWithKey
mapFM               --> mapWithKey
filterFM            --> filterWithKey
sizeFM              --> size
eqFM                --> Map has "Eq" context instead
isEmptyFM           --> null
elemFM              --> member                | argument order changed!
lookupFM            --> lookup                | argument order changed!
lookupWithDefaultFM --> findWithDefault       | argument order changed!
keyOrder            --> removed, because "Ord" context is used now
fmToList            --> toList
keysFM              --> keys
eltsFM              --> elems
fmSortBy            --> sortWithMap    | Will sort given by "<" of "Ord" context
minFM               --> lookupMin
maxFM               --> lookupMax
fmToListPreOrder    --> toPreOrderList

List -> Data.list

Maybe -> Data.Maybe   | now using Monad instance

Either -> Data.Either

Char -> Data.Char

Directory -> System.Directory
Renames:
fileSize -> getFileSize

FilePath -> System.FilePath

IO -> System.IO

Random -> System.Random

Function ->  Data.Function    (on, fix)
         bzw Data.Tuple.Extra (first, second, (***), (&&&), both)

Prelude -> Removed Either type

State -> Control.Monad.Trans.State, now with monad transformer
Renames:
bindS      -> Monad instance, >>=
bindS_     -> Monad instance, >>
returnS    -> Monad instance, return
getS       -> get
putS       -> put
modifyS    -> modify
sequenceS  -> sequence
sequenceS_ -> sequence_
mapS       -> mapM
mapS_      -> mapM_
liftS      -> liftM
liftS2     -> liftM2

ErrorState -> Control.Monad.ErrorState
Renames:
evalES      -> runError
returnES    -> Monad instance, return
>+=         -> Monad instance, >>=
>+          -> *>
getS        -> get
putS        -> put
modifyS     -> modify
mapS        -> mapM
concatMapES -> concatMapM
mapAccumES  -> mapAccumM

SearchTree -> Algorithm.SearchTree

AllSolutions -> Language.Curry.AllSolutions

Findall -> Language.Curry.Findall

AnsiCodes -> System.Console.ANSI.Codes

CPNS -> Network.CPNS //TODO: get rid of ReadShowTerm

Socket -> Network.Socket //TODO: Function renaming?

ValueSequence -> Algorithm.ValueSequence //TODO: rename functions

Dequeue -> Algorithm.Queue

GetOpt -> System.Console.GetOpt

Global -> System.IO.Global

NamedSocket -> Network.NamedSocket

Pretty -> Text.PrettyPrint

RedBlackTree -> Algorithm.RedBlackTree
Now uses Ord Context instead of explicit ordering function.
Renames:
tree2list -> toList

SearchTreeGenerators -> Algorithm.SearchTree.Generators

SearchTreeTraversal -> Algorithm.SearchTree.Traversal

ShowS -> Text.Show
